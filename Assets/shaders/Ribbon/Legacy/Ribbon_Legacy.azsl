/* 
 *----------------------------------------------------------------------------
 * This program is the property of Persistant Studios SARL.
 *
 * You may not redistribute it and/or modify it under any conditions
 * without written permission from Persistant Studios SARL, unless
 * otherwise stated in the latest Persistant Studios Code License.
 *
 * See the Persistant Studios Code License for further details.
 *----------------------------------------------------------------------------
*/

#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include <Atom/Features/PBR/ForwardPassSrg.azsli>
#include "../../Common/MaterialSrg.azsli"
#include "../../Common/RibbonSrg.azsli"

#include "../../Common/RendererFeatures.azsli"

struct VertexInput
{
    float4 m_position : POSITION;
    float2 m_texCoord0 : UV0;

    uint m_vertexID : SV_VertexID;
};

struct VertexInputAtlasBlend
{
    float3 m_position : POSITION;
    float2 m_texCoord0 : UV0;
    float2 m_texCoord1 : UV1;
    float m_texFrameLerp : UV2;

    uint m_vertexID : SV_VertexID;
};

struct VertexInputCorrectDeformation
{
    float3 m_position : POSITION;
    float2 m_texCoord0 : UV0;
    float4 m_UVRemap : UV1;
    float2 m_UVFactors : UV2;

    uint m_vertexID : SV_VertexID;
};

struct VertexOutput
{
    float4 m_position : SV_Position;
    float2 m_texCoord0 : UV0;
    float4 m_diffuseColor : UV1;
    float3 m_emissiveColor : UV2;
    float m_alphaCursor : UV3;
    float4 m_clipPosition : UV4;
};

struct VertexOutputAtlasBlend
{
    float4 m_position : SV_Position;
    float2 m_texCoord0 : UV0;
    float2 m_texCoord1 : UV1;
    float m_texFrameLerp : UV2;
    float4 m_diffuseColor : UV3;
    float3 m_emissiveColor : UV4;
    float m_alphaCursor : UV5;
    float4 m_clipPosition : UV6;
};

struct VertexOutputCorrectDeformation
{
    float4 m_position : SV_Position;
    float2 m_texCoord0 : UV0;
    float4 m_UVRemap : UV1;
    float4 m_UVFactors : UV2;
    float4 m_diffuseColor : UV3;
    float3 m_emissiveColor : UV4;
    float m_alphaCursor : UV5;
    float4 m_clipPosition : UV6;
};

VertexOutput RibbonVS(VertexInput input)
{
    VertexOutput    output;

    // Billboarding outputs:
    output.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(input.m_position.xyz, 1.0f));
    output.m_clipPosition = output.m_position;
    output.m_texCoord0 = input.m_texCoord0;

    uint    particleID = GetParticleIdx(input.m_vertexID);

    // Diffuse particle color:
    output.m_diffuseColor = float4(0, 0, 0, 0);
    if (HasOneRendererFlags(Has_Diffuse))
        output.m_diffuseColor = RendererSrg::m_diffuseColors[particleID];
    // Emissive particle color:
    output.m_emissiveColor = float3(0, 0, 0);
    if (HasOneRendererFlags(Has_Emissive))
        output.m_emissiveColor = GetEmissiveParticleColor(particleID);
    // Alpha remap:
    output.m_alphaCursor = 0;
    if (HasOneRendererFlags(Has_AlphaRemap))
        output.m_alphaCursor = RendererSrg::m_alphaCursors[particleID];
    return output;
}

VertexOutputAtlasBlend RibbonVS_AtlasBlend(VertexInputAtlasBlend input)
{
    VertexOutputAtlasBlend    output;

    // Billboarding outputs:
    output.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(input.m_position.xyz, 1.0f));
    output.m_clipPosition = output.m_position;
    output.m_texCoord0 = input.m_texCoord0;
    output.m_texCoord1 = input.m_texCoord1;
    output.m_texFrameLerp = frac(input.m_texFrameLerp);

    uint    particleID = GetParticleIdx(input.m_vertexID);

    // Diffuse particle color:
    output.m_diffuseColor = float4(0, 0, 0, 0);
    if (HasOneRendererFlags(Has_Diffuse))
        output.m_diffuseColor = RendererSrg::m_diffuseColors[particleID];
    // Emissive particle color:
    output.m_emissiveColor = float3(0, 0, 0);
    if (HasOneRendererFlags(Has_Emissive))
        output.m_emissiveColor = GetEmissiveParticleColor(particleID);
    // Alpha remap:
    output.m_alphaCursor = 0;
    if (HasOneRendererFlags(Has_AlphaRemap))
        output.m_alphaCursor = RendererSrg::m_alphaCursors[particleID];
    return output;
}

VertexOutputCorrectDeformation RibbonVS_CorrectDeformation(VertexInputCorrectDeformation input)
{
    VertexOutputCorrectDeformation    output;

    // Billboarding outputs:
    output.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(input.m_position.xyz, 1.0f));
    output.m_clipPosition = output.m_position;
    output.m_texCoord0 = input.m_texCoord0;
    output.m_UVRemap = input.m_UVRemap;
    output.m_UVFactors = GetCorrectDeformationUVFactors(input.m_UVFactors, input.m_vertexID);

    uint    particleID = GetParticleIdx(input.m_vertexID);

    // Diffuse particle color:
    output.m_diffuseColor = float4(0, 0, 0, 0);
    if (HasOneRendererFlags(Has_Diffuse))
        output.m_diffuseColor = RendererSrg::m_diffuseColors[particleID];
    // Emissive particle color:
    output.m_emissiveColor = float3(0, 0, 0);
    if (HasOneRendererFlags(Has_Emissive))
        output.m_emissiveColor = GetEmissiveParticleColor(particleID);
    // Alpha remap:
    output.m_alphaCursor = 0;
    if (HasOneRendererFlags(Has_AlphaRemap))
        output.m_alphaCursor = RendererSrg::m_alphaCursors[particleID];
    return output;
}

struct PixelOutput
{
    float4 m_color : SV_Target0;
};

PixelOutput RibbonFS(VertexOutput input)
{
    PixelOutput output;

    float4 diffuseColor = GetDiffuseColor(input.m_texCoord0);
    if (HasOneRendererFlags(Has_AlphaRemap))
        diffuseColor = ApplyAlphaRemap(diffuseColor, input.m_alphaCursor);
    diffuseColor *= input.m_diffuseColor;
    diffuseColor.a = clamp(diffuseColor.a, 0, 1);

    ApplyOpaqueMasked(diffuseColor.a);

    float4 emissiveColor = GetEmissiveColor(input.m_texCoord0);

    // Soft particles:
    if (HasOneRendererFlags(Has_Soft))
    {
        float3 clipPos = input.m_clipPosition.xyz / input.m_clipPosition.w;
        float fade = GetSoftParticleFade(clipPos);
        diffuseColor.a *= fade;
        emissiveColor.a *= fade;
    }

    emissiveColor.rgb *= input.m_emissiveColor * emissiveColor.a;
    output.m_color = float4(diffuseColor.rgb + emissiveColor.rgb, diffuseColor.a);
    return output;
}

PixelOutput RibbonFS_AtlasBlend(VertexOutputAtlasBlend input)
{
    PixelOutput output;

    float2  texCoord0 = input.m_texCoord0;
    float2  texCoord1 = input.m_texCoord1;

    GetMotionVectorsUV(texCoord0, texCoord1, input.m_texFrameLerp);

    float4 diffuseColor = GetDiffuseColor(texCoord0, texCoord1, input.m_texFrameLerp);
    if (HasOneRendererFlags(Has_AlphaRemap))
        diffuseColor = ApplyAlphaRemap(diffuseColor, input.m_alphaCursor);
    diffuseColor *= input.m_diffuseColor;
    diffuseColor.a = clamp(diffuseColor.a, 0, 1);

    ApplyOpaqueMasked(diffuseColor.a);

    float4 emissiveColor = GetEmissiveColor(texCoord0, texCoord1, input.m_texFrameLerp);

    // Soft particles:
    if (HasOneRendererFlags(Has_Soft))
    {
        float3 clipPos = input.m_clipPosition.xyz / input.m_clipPosition.w;
        float fade = GetSoftParticleFade(clipPos);
        diffuseColor.a *= fade;
        emissiveColor.a *= fade;
    }

    emissiveColor.rgb *= input.m_emissiveColor * emissiveColor.a;
    output.m_color = float4(diffuseColor.rgb + emissiveColor.rgb, diffuseColor.a);
    return output;
}

PixelOutput RibbonFS_CorrectDeformation(VertexOutputCorrectDeformation input)
{
    PixelOutput output;

    float2 texCoord = GetCorrectDeformationUV(input.m_texCoord0, input.m_UVFactors, input.m_UVRemap);

    float4 diffuseColor = GetDiffuseColor(texCoord);
    if (HasOneRendererFlags(Has_AlphaRemap))
        diffuseColor = ApplyAlphaRemap(diffuseColor, input.m_alphaCursor);
    diffuseColor *= input.m_diffuseColor;
    diffuseColor.a = clamp(diffuseColor.a, 0, 1);

    ApplyOpaqueMasked(diffuseColor.a);

    float4 emissiveColor = GetEmissiveColor(texCoord);

    // Soft particles:
    if (HasOneRendererFlags(Has_Soft))
    {
        float3 clipPos = input.m_clipPosition.xyz / input.m_clipPosition.w;
        float fade = GetSoftParticleFade(clipPos);
        diffuseColor.a *= fade;
        emissiveColor.a *= fade;
    }

    emissiveColor.rgb *= input.m_emissiveColor * emissiveColor.a;
    output.m_color = float4(diffuseColor.rgb + emissiveColor.rgb, diffuseColor.a);
    return output;
}
