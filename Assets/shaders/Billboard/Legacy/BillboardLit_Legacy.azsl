/* 
 *----------------------------------------------------------------------------
 * This program is the property of Persistant Studios SARL.
 *
 * You may not redistribute it and/or modify it under any conditions
 * without written permission from Persistant Studios SARL, unless
 * otherwise stated in the latest Persistant Studios Code License.
 *
 * See the Persistant Studios Code License for further details.
 *----------------------------------------------------------------------------
*/

#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include "../../Common/MaterialSrg.azsli"

#include "../../Common/LightingHelper.azsli"
// Billboarding shader:
#define     PK_LIT_SHADER
#include "../../Common/ComputeBillboardVertex.azsli"
// Material:
#include "../../Common/RendererFeatures.azsli"

struct VertexInput
{
    float2 m_uv : POSITION;
    uint m_instanceID : SV_InstanceID;
};

struct VSOutput
{
    linear centroid float4 m_position : SV_Position;
    float3 m_normal: NORMAL;
    float3 m_tangent : TANGENT; 
    float3 m_bitangent : BITANGENT; 
    float3 m_worldPosition : UV0;

    float2 m_texCoord0 : UV1;
    float2 m_texCoord1 : UV2;
    float  m_texFrameLerp : UV3;
    float4 m_diffuseColor : COLOR0;
    float3 m_emissiveColor : COLOR1;
    float m_alphaCursor : UV4;
    float4 m_clipPosition : UV5;

    float3 m_shadowCoords[ViewSrg::MaxCascadeCount] : UV6;
};

VSOutput BillboardVS(VertexInput input)
{
    VSOutput    output;
    uint        particleIdx = RendererSrg::m_indices[input.m_instanceID];

    // Billboarding outputs:
    float3  vtxWorldPos;
    float3  vtxNormal;
    float4  vtxTangent;
    float2  vtxUV0;
    float2  vtxUV1;
    float   vtxTexFrameLerp;

    ComputeBillboardVertex(particleIdx, input.m_uv, vtxWorldPos, vtxNormal, vtxTangent, vtxUV0, vtxUV1, vtxTexFrameLerp);

    // directional light shadow 
    const uint shadowIndex = ViewSrg::m_shadowIndexDirectionalLight;
    if (o_enableShadows && shadowIndex < SceneSrg::m_directionalLightCount)
        DirectionalLightShadow::GetShadowCoords(shadowIndex, vtxWorldPos, output.m_shadowCoords);

    // TBN:
    float3 vtxBitangent = cross(vtxNormal, vtxTangent.xyz) * vtxTangent.w;

    output.m_normal = vtxNormal;
    output.m_tangent = vtxTangent.xyz;
    output.m_bitangent = vtxBitangent;
    output.m_worldPosition = vtxWorldPos;
    output.m_position = mul(ViewSrg::m_viewProjectionMatrix, float4(vtxWorldPos, 1.0f));
    output.m_clipPosition = output.m_position;
    output.m_texCoord0 = vtxUV0;

    // Atlas animation blending:
    if (HasOneRendererFlags(Has_AnimBlend))
    {
        output.m_texCoord1 = vtxUV1;
        output.m_texFrameLerp = vtxTexFrameLerp;
    }
    else
    {
        output.m_texCoord1 = float2(0, 0);
        output.m_texFrameLerp = 0;
    }
    // Diffuse particle color:
    output.m_diffuseColor = float4(0, 0, 0, 0);
    if (HasOneRendererFlags(Has_Diffuse))
        output.m_diffuseColor = RendererSrg::m_diffuseColors[particleIdx];
    // Emissive particle color:
    output.m_emissiveColor = float3(0, 0, 0);
    if (HasOneRendererFlags(Has_Emissive))
        output.m_emissiveColor = GetEmissiveParticleColor(particleIdx);
    // Alpha remap:
    output.m_alphaCursor = 0;
    if (HasOneRendererFlags(Has_AlphaRemap))
        output.m_alphaCursor = RendererSrg::m_alphaCursors[particleIdx];
    return output;
}

ForwardPassOutput BillboardFS(VSOutput input, bool isFrontFace : SV_IsFrontFace)
{
    float2  texCoord0 = input.m_texCoord0;
    float2  texCoord1 = input.m_texCoord1;

    // Motion vectors:
    GetMotionVectorsUV(texCoord0, texCoord1, input.m_texFrameLerp);

    // Diffuse:
    float4 diffuseColor = float4(1, 1, 1, 1);
    if (HasOneRendererFlags(Has_AnimBlend))
        diffuseColor = GetDiffuseColor(texCoord0, texCoord1, input.m_texFrameLerp);
    else
        diffuseColor = GetDiffuseColor(texCoord0);
    if (HasOneRendererFlags(Has_AlphaRemap))
        diffuseColor = ApplyAlphaRemap(diffuseColor, input.m_alphaCursor);
    diffuseColor *= input.m_diffuseColor;
    diffuseColor.a = clamp(diffuseColor.a, 0, 1);

	ApplyOpaqueMasked(diffuseColor.a);

    // Emissive:
    float4 emissiveColor = float4(0, 0, 0, 0);
    if (HasOneRendererFlags(Has_AnimBlend))
        emissiveColor = GetEmissiveColor(texCoord0, texCoord1, input.m_texFrameLerp);
    else
        emissiveColor = GetEmissiveColor(texCoord0);

    float3 normal = normalize(isFrontFace ? input.m_normal : -input.m_normal);
    const float3  tangent = normalize(input.m_tangent);
    const float3  bitangent = normalize(input.m_bitangent);
	
    // Normal map:
    if (HasOneRendererFlags(Has_NormalMap))
    {
        float2 texNormal = MaterialSrg::m_normalMap.Sample(MaterialSrg::m_sampler, input.m_texCoord0).xy;
        if (HasOneRendererFlags(Has_AnimBlend))
        {
            // Lerping between normal maps is not the correct way to handle that
            // We should use ReorientTangentSpaceNormal instead
            float2 texNormal1 = MaterialSrg::m_normalMap.Sample(MaterialSrg::m_sampler, input.m_texCoord1).xy;
            texNormal = lerp(texNormal, texNormal1, input.m_texFrameLerp);
        }
        normal = GetWorldSpaceNormal(texNormal, normal, tangent, bitangent);
    }

    if (HasOneRendererFlags(Has_Soft))
    {
        float3 clipPos = input.m_clipPosition.xyz / input.m_clipPosition.w;
        float fade = GetSoftParticleFade(clipPos);
        diffuseColor.a *= fade;
        emissiveColor.a *= fade;
    }

    emissiveColor.rgb *= input.m_emissiveColor * emissiveColor.a;

    // Compute lighting:
    return ComputeParticleLighting( input.m_worldPosition,
                                    input.m_position,
                                    input.m_shadowCoords,
                                    normal,
                                    tangent,
                                    bitangent,
                                    diffuseColor,
                                    emissiveColor.rgb);
}
